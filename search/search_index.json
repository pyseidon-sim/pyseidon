{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PySeidon - A Data-Driven Maritime Port Simulator \ud83c\udf0a Pyseidon is an extendable and modular software for maritime port simulation. This software uses entity-component system approach making it highly customizable for various end goals and easily built upon. Overview PySeidon was primarily designed for port scenario testing, but can be used for a variety of other tasks. Software can be adapted to simulate any maritime port provided that the required data is available . The simulator can be tested with different factors, such as: New/different anchorage location Different number of tugboat/pilots available Different priority order depending on ship class/size Etc... PySeidon's output can then give useful insights whether the given change improves certain Key Performance Indicators (check this repository for scripts to analyse simulation results). PySeidon can be used to create new data for various downstream tasks (e.g. anomaly detection), approximate impact on Key Performance Indicators of some decision, novelty introduced in a port. The supplemental visualization software can be used to analyse general (or created by simulation) AIS data over time or analyse simulation states (for debugging). Features Simulation of the following agents and infrastructure elements Agents: vessel, tugboats, pilots Infrastructure components: berths, anchorages, tugboat rendezvous and storage locations, pilot rendezvous and storage locations Introduction of anomalies such as randomized berth inspections, tugboat malfunctions, anomalous vessel velocity. These can be used to create datasets that are currently not available Visualization of the simulation: infrastructure components and agents, including an overview of vessel and berth information at any moment in time Simulation of anomalies: random berth inspection, tugboat malfunctions, unusual vessel velocities Clean way of conducting experiments of the simulation (multiple runs, no graphics, aggregating output data of the simulation) The simulation engine relies on the input data, minimal actual code modification (model and main.py ) is required to adapt to different maritime ports if no additional features are to be implemented Installation Install the required dependencies by running pip install -r requirements.txt (you might want to use Anaconda to manage your Python environments). You might also have to install libgeos (a requirement of Shapely ). On Ubuntu you can install it by running sudo apt-get install libgeos-dev Running the simulator > python main.py --help usage: main.py [-h] --out OUT [--step STEP] [--max-time MAX_TIME] [--verbose VERBOSE] [--graphics GRAPHICS] [--cache CACHE] [--tugs-allocation-data TUGS_ALLOCATION_DATA] [--single-tugs-company SINGLE_TUGS_COMPANY] [--fixed-generation FIXED_GENERATION] [--berth-check-prob BERTH_CHECK_PROB] [--anomalous-speed ANOMALOUS_SPEED] [--tugs-malfunction TUGS_MALFUNCTION] [--tugs-break-percentage-idle TUGS_BREAK_PERCENTAGE_IDLE] [--tugs-break-percentage-busy TUGS_BREAK_PERCENTAGE_BUSY] [--seed SEED] PySeidon - a Maritime Port Simulator optional arguments: -h, --help show this help message and exit --out OUT Output directory --step STEP Step size (seconds) --max-time MAX_TIME Maximum simulation time --verbose VERBOSE Verbose output? [y/n] --graphics GRAPHICS Display the simulation on-screen? [y/n] --cache CACHE Use the traces cache? [y/n] --tugs-allocation-data TUGS_ALLOCATION_DATA Allocate tugs from data or randomly? [y/n] --single-tugs-company SINGLE_TUGS_COMPANY Use a single tugboat company? [y/n] --fixed-generation FIXED_GENERATION Generate all arrivals at the beginning of the simulation or on the fly? [y/n] --berth-check-prob BERTH_CHECK_PROB The probability of a randomized check for a berth (0 <= x <= 1) --anomalous-speed ANOMALOUS_SPEED Whether to add speed anomalies [y/n] --tugs-malfunction TUGS_MALFUNCTION Introduce tugs breaking down anomaly? [y/n] --tugs-break-percentage-idle TUGS_BREAK_PERCENTAGE_IDLE Probability of an idle tug malfunctioning at every iteration. --tugs-break-percentage-busy TUGS_BREAK_PERCENTAGE_BUSY Probability of a busy tug malfunctioning at every iteration. --seed SEED Seed for random generators. To run the simulator execute python main.py with the desired flags as shown above. When you want to interrupt the simulation, press CTRL + C in the terminal window. The app will close and output the simulation statistics to the terminal. Note: closing the app window will not display the statistics. Running tests We use pytest as the test runner. In order to run tests execute pytest in the root folder. For coverage information run pytest --cov (you might need to install pytest-cov first). Output analysis > python output_analysis.py --help usage: output_analysis.py [-h] --i I [--w W] [--steady STEADY] A script that takes in a directory of simulation output files, where each file represents an independent run of the simulation, and computes some Key Performance Indicators: - time each vessel class spends in anchorages - time each vessel class spends inside the port - total port throughput for each vessel class - total tugboats throughput of each vessel class - total service times of tugboats for each vessel class - total berth service time for each vessel class. This script also provides a graph with a smoothed curve of vessel throughput for a specific class. optional arguments: -h, --help show this help message and exit --i I Directory of output files of the simulation --w W Define window in seconds for which to compute metrics. Default: 86400 sec (1 day) --steady STEADY Define a specified time (in seconds) from which to start calculating KPIs. This can be usedto specify when the simulation enters a steady state. This time can be uncovered when running this script once without this parameter. Then graphically inspecting the output plot and determining when the curve has plateaued. To perform output analysis, run python output_analysis.py --i <input-dir> . After running this script for the first time, look at the computed graph. Decide when the simulation enters steady-state using a graphical method . After you decide when the simulation enters steady-state, run the script with the --steady <steady time point> where <steady time point> is a time (in seconds) after which the simulation enters steady state as determined by the aforementioned graphical inspection method. Thus, the script will now compute the KPIs only for the steady-state version of the simulation.","title":"Home"},{"location":"#pyseidon-a-data-driven-maritime-port-simulator","text":"Pyseidon is an extendable and modular software for maritime port simulation. This software uses entity-component system approach making it highly customizable for various end goals and easily built upon.","title":"PySeidon - A Data-Driven Maritime Port Simulator \ud83c\udf0a"},{"location":"#overview","text":"PySeidon was primarily designed for port scenario testing, but can be used for a variety of other tasks. Software can be adapted to simulate any maritime port provided that the required data is available . The simulator can be tested with different factors, such as: New/different anchorage location Different number of tugboat/pilots available Different priority order depending on ship class/size Etc... PySeidon's output can then give useful insights whether the given change improves certain Key Performance Indicators (check this repository for scripts to analyse simulation results). PySeidon can be used to create new data for various downstream tasks (e.g. anomaly detection), approximate impact on Key Performance Indicators of some decision, novelty introduced in a port. The supplemental visualization software can be used to analyse general (or created by simulation) AIS data over time or analyse simulation states (for debugging).","title":"Overview"},{"location":"#features","text":"Simulation of the following agents and infrastructure elements Agents: vessel, tugboats, pilots Infrastructure components: berths, anchorages, tugboat rendezvous and storage locations, pilot rendezvous and storage locations Introduction of anomalies such as randomized berth inspections, tugboat malfunctions, anomalous vessel velocity. These can be used to create datasets that are currently not available Visualization of the simulation: infrastructure components and agents, including an overview of vessel and berth information at any moment in time Simulation of anomalies: random berth inspection, tugboat malfunctions, unusual vessel velocities Clean way of conducting experiments of the simulation (multiple runs, no graphics, aggregating output data of the simulation) The simulation engine relies on the input data, minimal actual code modification (model and main.py ) is required to adapt to different maritime ports if no additional features are to be implemented","title":"Features"},{"location":"#installation","text":"Install the required dependencies by running pip install -r requirements.txt (you might want to use Anaconda to manage your Python environments). You might also have to install libgeos (a requirement of Shapely ). On Ubuntu you can install it by running sudo apt-get install libgeos-dev","title":"Installation"},{"location":"#running-the-simulator","text":"> python main.py --help usage: main.py [-h] --out OUT [--step STEP] [--max-time MAX_TIME] [--verbose VERBOSE] [--graphics GRAPHICS] [--cache CACHE] [--tugs-allocation-data TUGS_ALLOCATION_DATA] [--single-tugs-company SINGLE_TUGS_COMPANY] [--fixed-generation FIXED_GENERATION] [--berth-check-prob BERTH_CHECK_PROB] [--anomalous-speed ANOMALOUS_SPEED] [--tugs-malfunction TUGS_MALFUNCTION] [--tugs-break-percentage-idle TUGS_BREAK_PERCENTAGE_IDLE] [--tugs-break-percentage-busy TUGS_BREAK_PERCENTAGE_BUSY] [--seed SEED] PySeidon - a Maritime Port Simulator optional arguments: -h, --help show this help message and exit --out OUT Output directory --step STEP Step size (seconds) --max-time MAX_TIME Maximum simulation time --verbose VERBOSE Verbose output? [y/n] --graphics GRAPHICS Display the simulation on-screen? [y/n] --cache CACHE Use the traces cache? [y/n] --tugs-allocation-data TUGS_ALLOCATION_DATA Allocate tugs from data or randomly? [y/n] --single-tugs-company SINGLE_TUGS_COMPANY Use a single tugboat company? [y/n] --fixed-generation FIXED_GENERATION Generate all arrivals at the beginning of the simulation or on the fly? [y/n] --berth-check-prob BERTH_CHECK_PROB The probability of a randomized check for a berth (0 <= x <= 1) --anomalous-speed ANOMALOUS_SPEED Whether to add speed anomalies [y/n] --tugs-malfunction TUGS_MALFUNCTION Introduce tugs breaking down anomaly? [y/n] --tugs-break-percentage-idle TUGS_BREAK_PERCENTAGE_IDLE Probability of an idle tug malfunctioning at every iteration. --tugs-break-percentage-busy TUGS_BREAK_PERCENTAGE_BUSY Probability of a busy tug malfunctioning at every iteration. --seed SEED Seed for random generators. To run the simulator execute python main.py with the desired flags as shown above. When you want to interrupt the simulation, press CTRL + C in the terminal window. The app will close and output the simulation statistics to the terminal. Note: closing the app window will not display the statistics.","title":"Running the simulator"},{"location":"#running-tests","text":"We use pytest as the test runner. In order to run tests execute pytest in the root folder. For coverage information run pytest --cov (you might need to install pytest-cov first).","title":"Running tests"},{"location":"#output-analysis","text":"> python output_analysis.py --help usage: output_analysis.py [-h] --i I [--w W] [--steady STEADY] A script that takes in a directory of simulation output files, where each file represents an independent run of the simulation, and computes some Key Performance Indicators: - time each vessel class spends in anchorages - time each vessel class spends inside the port - total port throughput for each vessel class - total tugboats throughput of each vessel class - total service times of tugboats for each vessel class - total berth service time for each vessel class. This script also provides a graph with a smoothed curve of vessel throughput for a specific class. optional arguments: -h, --help show this help message and exit --i I Directory of output files of the simulation --w W Define window in seconds for which to compute metrics. Default: 86400 sec (1 day) --steady STEADY Define a specified time (in seconds) from which to start calculating KPIs. This can be usedto specify when the simulation enters a steady state. This time can be uncovered when running this script once without this parameter. Then graphically inspecting the output plot and determining when the curve has plateaued. To perform output analysis, run python output_analysis.py --i <input-dir> . After running this script for the first time, look at the computed graph. Decide when the simulation enters steady-state using a graphical method . After you decide when the simulation enters steady-state, run the script with the --steady <steady time point> where <steady time point> is a time (in seconds) after which the simulation enters steady state as determined by the aforementioned graphical inspection method. Thus, the script will now compute the KPIs only for the steady-state version of the simulation.","title":"Output analysis"},{"location":"architecture/","text":"Simulation Architecture The simulation framework is based on the ESC Esper . This ECS system consists of the following elements: Entities : labels that represent simulated entities (vessels, berths, etc.). They have no properties or methods. Components provide properties and processors provide method implementations Components : data objects (such as position, velocity, etc.). They should NOT include any method or computation Processors : classes that process a set of entities identified by their components. For example a vessel entity might be characterized by a position, velocity and vessel_info components Please refer to the official Esper documentation for learning more. Packages The simulation framework is divided in the following packages: Components Contains data and finite state machines components for vessels and berths. Processors Contains the classes that interact directly with the simulation, such as generators (e.g. vessel generation), renderers etc. Following a reference of the main processors VesselGeneratorProcessor Generates new vessels provided an inter-arrival time distribution and a user-provided vessel properties generator, that generates vessel length, width, etc. (see VesselInfo for details) VesselGeneratorProcessor( # Simulation world world, # The inter-arrival time distribution lambda: np.random.exponential(scale=1), # The vessel properties generator lambda: return VesselInfo(...)) Renderers These components take care of rendering entities on-screen Timer Processor This processor is in charge of advancing the currently scheduled timer's internal clock Movement processor This processor simulates the vessel movement, currently using a simple fixed speed based model. Vessel Goal Formulator This processor insructs incoming vessels on their next goal, such as selecting and navigating to a target berth or departing. Environment This package wraps the packages used for interacting with the environment. The current packages are: Initializers Contains one-shot generation processed, used for setting up the simulation Navigation Contains classes used for generating vessel (or tugboats, etc.) paths Queries Contains utility functions and classes for fetching entities from the simulation world Layers This package contains layers used for the visualization but rendering code should be added via renderer processors. Model This package contains model-specific code that is FORBIDDEN from being used in other parts of the simulator. Instead model specific code should be injected to the consumer classes. For a practical example consider the VesselGeneratorProcessor . This class accepts two functions, one that generates an inter arrival time and one that generates the vessel properties: vessel_generator = VesselGeneratorProcessor( world, lambda: np.random.exponential(scale=15.0) * SECONDS_IN_MINUTE, lambda: VesselInfo(...)) This allow the VesselGeneratorProcessor to be model-agnostic and reusable. Note: some model-specific code is currently used by framework classes, this should be addressed. Utils Package for storing utilities functions and classes. The sub-package timer contains a SimulationTimer class that is used for dispatching future events and accepts a duration in seconds and a TimerScheduler singleton that is used to add timers to the simulation. Timers can be scheduled using the following code: timer = SimulationTimer( duration=1000, # The function to be executed after the timer has completed target_function=lambda: ...) TimerScheduler.get_instance().schedule(timer)","title":"Simulation Architecture"},{"location":"architecture/#simulation-architecture","text":"The simulation framework is based on the ESC Esper . This ECS system consists of the following elements: Entities : labels that represent simulated entities (vessels, berths, etc.). They have no properties or methods. Components provide properties and processors provide method implementations Components : data objects (such as position, velocity, etc.). They should NOT include any method or computation Processors : classes that process a set of entities identified by their components. For example a vessel entity might be characterized by a position, velocity and vessel_info components Please refer to the official Esper documentation for learning more.","title":"Simulation Architecture"},{"location":"architecture/#packages","text":"The simulation framework is divided in the following packages:","title":"Packages"},{"location":"architecture/#components","text":"Contains data and finite state machines components for vessels and berths.","title":"Components"},{"location":"architecture/#processors","text":"Contains the classes that interact directly with the simulation, such as generators (e.g. vessel generation), renderers etc. Following a reference of the main processors","title":"Processors"},{"location":"architecture/#vesselgeneratorprocessor","text":"Generates new vessels provided an inter-arrival time distribution and a user-provided vessel properties generator, that generates vessel length, width, etc. (see VesselInfo for details) VesselGeneratorProcessor( # Simulation world world, # The inter-arrival time distribution lambda: np.random.exponential(scale=1), # The vessel properties generator lambda: return VesselInfo(...))","title":"VesselGeneratorProcessor"},{"location":"architecture/#renderers","text":"These components take care of rendering entities on-screen","title":"Renderers"},{"location":"architecture/#timer-processor","text":"This processor is in charge of advancing the currently scheduled timer's internal clock","title":"Timer Processor"},{"location":"architecture/#movement-processor","text":"This processor simulates the vessel movement, currently using a simple fixed speed based model.","title":"Movement processor"},{"location":"architecture/#vessel-goal-formulator","text":"This processor insructs incoming vessels on their next goal, such as selecting and navigating to a target berth or departing.","title":"Vessel Goal Formulator"},{"location":"architecture/#environment","text":"This package wraps the packages used for interacting with the environment. The current packages are:","title":"Environment"},{"location":"architecture/#initializers","text":"Contains one-shot generation processed, used for setting up the simulation","title":"Initializers"},{"location":"architecture/#navigation","text":"Contains classes used for generating vessel (or tugboats, etc.) paths","title":"Navigation"},{"location":"architecture/#queries","text":"Contains utility functions and classes for fetching entities from the simulation world","title":"Queries"},{"location":"architecture/#layers","text":"This package contains layers used for the visualization but rendering code should be added via renderer processors.","title":"Layers"},{"location":"architecture/#model","text":"This package contains model-specific code that is FORBIDDEN from being used in other parts of the simulator. Instead model specific code should be injected to the consumer classes. For a practical example consider the VesselGeneratorProcessor . This class accepts two functions, one that generates an inter arrival time and one that generates the vessel properties: vessel_generator = VesselGeneratorProcessor( world, lambda: np.random.exponential(scale=15.0) * SECONDS_IN_MINUTE, lambda: VesselInfo(...)) This allow the VesselGeneratorProcessor to be model-agnostic and reusable. Note: some model-specific code is currently used by framework classes, this should be addressed.","title":"Model"},{"location":"architecture/#utils","text":"Package for storing utilities functions and classes. The sub-package timer contains a SimulationTimer class that is used for dispatching future events and accepts a duration in seconds and a TimerScheduler singleton that is used to add timers to the simulation. Timers can be scheduled using the following code: timer = SimulationTimer( duration=1000, # The function to be executed after the timer has completed target_function=lambda: ...) TimerScheduler.get_instance().schedule(timer)","title":"Utils"},{"location":"data/","text":"Required data A detailed description of the datasets and their formats is presented after this section. The bare minimum data required to run the port simulation is the following (see the example model for further information): Definition of different vessel size classes and their parameters as well as different vessel content types. See vessel_class.py , vessel_content_type.py , vessel_type.py , vessel_distribution_factory.py in example_model . Polygons of sections of the port. See sections.geojson in example_data . Locations and parameters of berths. See berths.csv in example_data . The polygons of anchorages. See anchorages.geojson in example_data . Spawn areas of vessels. See spawn.geojson in example_data . Vessel inter-arrival mean times. See vessel_distribution_factory.py in example_model . The vessel service times at berths. See terminal-service-times.csv in example_data . Traces (paths) from the sea/ocean to the berths. See traces.geojson in example_data/traces . The following sections will explain some requirements in more details Sections Sections are defined as a GeoJSON FeatureCollection where each Feature is a polygon defining the section area along with the following properties: name : the section name speed : the minimum and maximum speed (in knots) allowed in this section Speed limitations are only applied to vessels, not to tugboats Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [ { \"type\": \"Feature\", \"properties\": { \"name\": \"section_1\", \"speed\": { \"class_1\": { \"min\": 0.0, \"max\": 10.0 }, \"class_2\": { \"min\": 0.0, \"max\": 10.0 } }, \"allowed_classes\": [] }, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [ [1.1111231, 11.23421], [1.1111231,11.23421], [1.1111231,11.23421], [1.1111231,11.23421], [1.1111231,11.23421] ] ] } }, ...] } Vessel traces/paths In order to make navigation possible the following kind of paths (in GeoJSON format) must be specified: ocean -> berth Each berth should have at least one of these paths, if such path does not exist the berth will not be used by the simulator ocean -> rendezvous Each rendezvous must have at least one path connecting it to the ocean rendezvous -> berth Usually each rendezvous location concerns a subset of the berths in the port, thus it is only required to connect berths to the rendezvous location(s) used in practice, not to all berth -> berth (optional) These paths are not currently used but they will be required when shifting (berth -> berth) voyages are implemented waiting location -> rendezvous These paths are used by tugboats to navigate between waiting locations and rendezvous points. At least one path for each (waiting location, rendezvous) pair is required Multiple paths concerning the same pair of elements (e.g. ocean -> berth:54) can be specified. In this case when such a path is needed the simulatior will choose one of the available paths at random. As an example, the following GeoJSON snipped describes a path connecting the ocean to berth 129 (described as berth:129 ). The IDs of berths and rendezvous location must match the ones assigned to berths and rendezvous in their respective data files. The GeoJSON file must be a FeatureCollection where each Feature describes a path using a LineString element. The coordinates of the LineString define the path and must include origin and destination. Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [{ \"type\": \"Feature\", \"geometry\": { \"type\": \"LineString\", \"coordinates\": [ [1.1111231, 11.23421], [1.1111231,11.23421], [1.1111231,11.23421], [1.1111231,11.23421], [1.1111231,11.23421] ] }, \"properties\": { \"origin\": \"ocean\", \"destination\": \"berth:129\" } }, ...] } Vessel spawn area The vessel spawn area defines a polygon where vessels are to be generated in (at a random point withing the polygon). The spawn area is defined by a GeoJSON file with a single polygon (and no properties) as in the example below: Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [{ \"type\": \"Feature\", \"properties\": {}, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ] ] } }] } Berths The set of berths in the simulated port must be provided as a csv file with the following columns: id : the berth ID, expressed as an integer name : the berth name lat, lon : coordinates (in WSG 84 format, a.k.a the standard one) description : optional berth description (not used by the simulator) type : the berth type (can be either jetty, berth or quay) max_quay_length : maximum allowed vessel length max_depth : the maximum allowed draught at this berth ship_types : corresponds to the content type the berth can process. liquid bulk container dry bulk chemical terminal (string): the terminal that the berth belongs to This is used for retrieving the time it takes to service a vessel (see terminal-service-times.csv ) since service times are given on a per-terminal basis section : the section of the port this berth is in See an exmple below: id,name,lat,lon,type,max_quay_length,max_depth,ship_types,terminal,section 0,Berth 1,31.52251026784937,1.227441038275049,quay,200,20,2,terminal 2,3 Terminal service times Terminal service times are defined by a csv file with the following columns: terminal : name of the terminal section : the section this terminal is in (unused?) class x : the mean amount of time (in seconds) it takes for berths in this terminal to process the vessel of class x Example: terminal,section,class 1,class 2 terminal 1,3,12000,12000 terminal 2,6,17000,20000 Anchorages Anchorages are defined by a GeoJSON file containing a FeatureCollection where each Feature defines a polygonal area for the anchorage plus the following properties: name : name of the anchorage max_draught : maximum draught (meters) of a ship for this anchorage id : id of the anchorage (unused) Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [ { \"type\": \"Feature\", \"properties\": { \"name\": \"1\", \"max_draught\": 20, \"id\": 0 }, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ] ] } }, ...] } The decision rules for allocating vessels to anchorages are defined in the model. Tugboat locations Rendezvous The rendezvous location(s) are defined by a GeoJSON file with a FeatureCollection where each Feature represents a waiting location as a Point with the following properties: id: the id of the waiting location vessel_final_destination : the destination sections for which this rendezvous point is used or, in other words: if a vessel needs to reach (following the example below) sections 11, 12 or 13 and needs tugging it will have to pass through this rendezvous point Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [ { \"type\": \"Feature\", \"properties\": { \"id\": \"1\", \"vessel_final_destination\": [11, 12, 13] }, \"geometry\": { \"type\": \"Point\", \"coordinates\": [ 1.1111231, 11.23421 ] } }, ...] } Waiting locations The tugboats waiting location(s) are defined by a GeoJSON file with a FeatureCollection where each Feature represents a waiting location as a Polygon with the following properties: id : id of the tugboat waiting location name : name of the tugboat waiting location companies : the companies that have tugboats standing by at this location tug_per_company : number of tugboats per company at this waiting location The length of this array must match the length of the companies array To simulate a single tugboat company simply specify an one-element array for both the companies and the tugs_per_company properties. Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [{ \"type\": \"Feature\", \"properties\": { \"id\": 11, \"tugboats_count\": 8, \"name\": \"Tug 1\", \"companies\": [\"Company 1\", \"Company 2\", \"Company 3\"], \"tugs_per_company\": [6, 4, 1] }, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [ [ 1.2222222, 11.2222223 ], [ 1.2222322, 11.2222222 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ] ] ] } }, ...] }","title":"Required data"},{"location":"data/#required-data","text":"A detailed description of the datasets and their formats is presented after this section. The bare minimum data required to run the port simulation is the following (see the example model for further information): Definition of different vessel size classes and their parameters as well as different vessel content types. See vessel_class.py , vessel_content_type.py , vessel_type.py , vessel_distribution_factory.py in example_model . Polygons of sections of the port. See sections.geojson in example_data . Locations and parameters of berths. See berths.csv in example_data . The polygons of anchorages. See anchorages.geojson in example_data . Spawn areas of vessels. See spawn.geojson in example_data . Vessel inter-arrival mean times. See vessel_distribution_factory.py in example_model . The vessel service times at berths. See terminal-service-times.csv in example_data . Traces (paths) from the sea/ocean to the berths. See traces.geojson in example_data/traces . The following sections will explain some requirements in more details","title":"Required data"},{"location":"data/#sections","text":"Sections are defined as a GeoJSON FeatureCollection where each Feature is a polygon defining the section area along with the following properties: name : the section name speed : the minimum and maximum speed (in knots) allowed in this section Speed limitations are only applied to vessels, not to tugboats Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [ { \"type\": \"Feature\", \"properties\": { \"name\": \"section_1\", \"speed\": { \"class_1\": { \"min\": 0.0, \"max\": 10.0 }, \"class_2\": { \"min\": 0.0, \"max\": 10.0 } }, \"allowed_classes\": [] }, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [ [1.1111231, 11.23421], [1.1111231,11.23421], [1.1111231,11.23421], [1.1111231,11.23421], [1.1111231,11.23421] ] ] } }, ...] }","title":"Sections"},{"location":"data/#vessel-tracespaths","text":"In order to make navigation possible the following kind of paths (in GeoJSON format) must be specified: ocean -> berth Each berth should have at least one of these paths, if such path does not exist the berth will not be used by the simulator ocean -> rendezvous Each rendezvous must have at least one path connecting it to the ocean rendezvous -> berth Usually each rendezvous location concerns a subset of the berths in the port, thus it is only required to connect berths to the rendezvous location(s) used in practice, not to all berth -> berth (optional) These paths are not currently used but they will be required when shifting (berth -> berth) voyages are implemented waiting location -> rendezvous These paths are used by tugboats to navigate between waiting locations and rendezvous points. At least one path for each (waiting location, rendezvous) pair is required Multiple paths concerning the same pair of elements (e.g. ocean -> berth:54) can be specified. In this case when such a path is needed the simulatior will choose one of the available paths at random. As an example, the following GeoJSON snipped describes a path connecting the ocean to berth 129 (described as berth:129 ). The IDs of berths and rendezvous location must match the ones assigned to berths and rendezvous in their respective data files. The GeoJSON file must be a FeatureCollection where each Feature describes a path using a LineString element. The coordinates of the LineString define the path and must include origin and destination. Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [{ \"type\": \"Feature\", \"geometry\": { \"type\": \"LineString\", \"coordinates\": [ [1.1111231, 11.23421], [1.1111231,11.23421], [1.1111231,11.23421], [1.1111231,11.23421], [1.1111231,11.23421] ] }, \"properties\": { \"origin\": \"ocean\", \"destination\": \"berth:129\" } }, ...] }","title":"Vessel traces/paths"},{"location":"data/#vessel-spawn-area","text":"The vessel spawn area defines a polygon where vessels are to be generated in (at a random point withing the polygon). The spawn area is defined by a GeoJSON file with a single polygon (and no properties) as in the example below: Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [{ \"type\": \"Feature\", \"properties\": {}, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ] ] } }] }","title":"Vessel spawn area"},{"location":"data/#berths","text":"The set of berths in the simulated port must be provided as a csv file with the following columns: id : the berth ID, expressed as an integer name : the berth name lat, lon : coordinates (in WSG 84 format, a.k.a the standard one) description : optional berth description (not used by the simulator) type : the berth type (can be either jetty, berth or quay) max_quay_length : maximum allowed vessel length max_depth : the maximum allowed draught at this berth ship_types : corresponds to the content type the berth can process. liquid bulk container dry bulk chemical terminal (string): the terminal that the berth belongs to This is used for retrieving the time it takes to service a vessel (see terminal-service-times.csv ) since service times are given on a per-terminal basis section : the section of the port this berth is in See an exmple below: id,name,lat,lon,type,max_quay_length,max_depth,ship_types,terminal,section 0,Berth 1,31.52251026784937,1.227441038275049,quay,200,20,2,terminal 2,3","title":"Berths"},{"location":"data/#terminal-service-times","text":"Terminal service times are defined by a csv file with the following columns: terminal : name of the terminal section : the section this terminal is in (unused?) class x : the mean amount of time (in seconds) it takes for berths in this terminal to process the vessel of class x Example: terminal,section,class 1,class 2 terminal 1,3,12000,12000 terminal 2,6,17000,20000","title":"Terminal service times"},{"location":"data/#anchorages","text":"Anchorages are defined by a GeoJSON file containing a FeatureCollection where each Feature defines a polygonal area for the anchorage plus the following properties: name : name of the anchorage max_draught : maximum draught (meters) of a ship for this anchorage id : id of the anchorage (unused) Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [ { \"type\": \"Feature\", \"properties\": { \"name\": \"1\", \"max_draught\": 20, \"id\": 0 }, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ] ] } }, ...] } The decision rules for allocating vessels to anchorages are defined in the model.","title":"Anchorages"},{"location":"data/#tugboat-locations","text":"","title":"Tugboat locations"},{"location":"data/#rendezvous","text":"The rendezvous location(s) are defined by a GeoJSON file with a FeatureCollection where each Feature represents a waiting location as a Point with the following properties: id: the id of the waiting location vessel_final_destination : the destination sections for which this rendezvous point is used or, in other words: if a vessel needs to reach (following the example below) sections 11, 12 or 13 and needs tugging it will have to pass through this rendezvous point Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [ { \"type\": \"Feature\", \"properties\": { \"id\": \"1\", \"vessel_final_destination\": [11, 12, 13] }, \"geometry\": { \"type\": \"Point\", \"coordinates\": [ 1.1111231, 11.23421 ] } }, ...] }","title":"Rendezvous"},{"location":"data/#waiting-locations","text":"The tugboats waiting location(s) are defined by a GeoJSON file with a FeatureCollection where each Feature represents a waiting location as a Polygon with the following properties: id : id of the tugboat waiting location name : name of the tugboat waiting location companies : the companies that have tugboats standing by at this location tug_per_company : number of tugboats per company at this waiting location The length of this array must match the length of the companies array To simulate a single tugboat company simply specify an one-element array for both the companies and the tugs_per_company properties. Note that the numbers in the example are random. { \"type\": \"FeatureCollection\", \"features\": [{ \"type\": \"Feature\", \"properties\": { \"id\": 11, \"tugboats_count\": 8, \"name\": \"Tug 1\", \"companies\": [\"Company 1\", \"Company 2\", \"Company 3\"], \"tugs_per_company\": [6, 4, 1] }, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [ [ 1.2222222, 11.2222223 ], [ 1.2222322, 11.2222222 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ], [ 1.1111231, 11.23421 ] ] ] } }, ...] }","title":"Waiting locations"},{"location":"features/","text":"Architecture Entity-component systems The simulation framework is based on the ESC Esper . This ECS system consists of the following elements: Entities : labels that represent simulated entities (vessels, berths, etc.). They have no properties or methods. Components provide properties and processors provide method implementations Components : data objects (such as position, velocity, etc.). They should NOT include any method or computation Processors : classes that process a set of entities identified by their components. For example a vessel entity might be characterized by a position, velocity and vessel_info components As an example consider the mock simulation world in the figure below. There are two classes of entities, namely Vessel and Terminal which are respectively composed by ( Position , Path ) and ( Position ). Each system processes a subset of entities at each tick of the simulation, for example, the Rendering system will query all entities who have a Position component and display them on-screen, while the Movement system will only care about entities with Position and Path components. Packages This section provides a schematic overview of the major packages that compose the simulation framework Components Environment Miscellaneous Processors Simulated agents and infrastructure The simulation can simulate the following agents and infrastructure components: Agents Vessel The ship which needs the port services for loading/unloading cargo, maintenance, fuel, etc. The behavior of incoming vessels is simulated using the following state machine: Following the previous diagrams vessels are either routed to an anchorage, a rendezvous or straight to the terminal depending on resources requests and availability (a more detailed diagram is shown in the messaging section). The navigation of vessels is simulated using paths extracted (and augmented) from AIS data. Movement is simulated using a simple speed based model (where acceleration/deceleration is instantaneous). Pilots Pilots (working for the port) assist vessels entering or leaving a port. Pilots do so as they are experts of the port infrastructure and navigating big vessels in the port. The pilots are described by the following FSM diagram: Tugboats A tugboat is a strongly built powerful boat, that is used for towing and pushing ( Merriam-Webster ). Tugboats are used to maneuver large vessels inside the port with more accuracy and precision. The simulated behavior of tugboats is described by the following FSM diagram: Infrastructure Berth The location where a ship lies when being serviced or waiting for departure. Berths are grouped into a terminal, which is usually dedicated to a single cargo type (e.g. oil, containers, etc.) Anchorage An anchorage is defined as the area where vessels drop anchor, or anchor, awaiting their entry into that part of the harbour reserved for performing typical port type operations (loading, unloading, supplies, repairs, etc.), which however does not exclude these operations frequently being undertaken at the anchorages (Puertos Del Estado, 2007) Tugboats locations Rendezvous locations: meeting points between vessels and tugboats where tugboats are connected to vessels and the tugging process starts Waiting locations: locations used to park tugboats when their services are not required Pilot locations Rendezvous locations: meeting points between vessels and pilots where pilots board the vessel and pilotage starts Waiting locations: locations used to park pilot tender vessels when their services are not required Port sections The frameworks allows to separate the port waterways (navigable area inside the port) in sections. Each section has the following constraints: Maximum and minimum speed Agents communication The agents in the simulation can communicate via the MessageBroker . Each message has a sender , a receiver a message_type and an optional data property. Simulation entities are identified by their entity id and unique agents (such as the harbour master) are identified by a string. In practice, this means that if a vessel (say entity 195) wants to send a message to the harbour master the sender will be ent:195 and the receiver will be harbour-master . Such a message can be created as follows message = SimulationMessage( sender=\"vessel:195\", destination=\"harbour-master\", message=VesselMessageType.CHANGE_SECTION) In the current implementation only vessel agents communicate with the harbour-master agent which takes care of allocating port resources to the vessel. In practice this does not happen, for instance tugboat companies communicate directly with the shipping company that owns the vessel for booking tugs. Vessel messages Each vessel entity generates the various messages and sends them to the harbour-master . The following diagram describes which messages are sent to the harbour-master entity at each state of the vessel process (including the decisions taken by the harbour-master entity) The harbour-master processor handles such messages based on a pluggable strategy. The default strategy is in the class DefaultVesselStrategy Moreover, each vessel notifies the harbour-master when it enters/exits a section. These events are not handled directly by the harbour master and a modeller can handle them by setting on_enter_section and on_exit_section on the HarbourMasterProcessor class. For example: hm_processor = HarbourMasterProcessor( world=world, vessel_strategy=vessel_strategy, logger=vessel_event_logger) # Handle the vessel exited section event hm_processor.on_exit_section = lambda msg, ent, vessel_info: ... Simulated anomalies Random berth inspection There exists a probability p that every time a vessel is serviced at a berth, it might happen that a berth inspection occurs. In which case, the berth service time is increased by a random time (or, by default, 5 hours). Unusual vessel velocities Using the simulation of the Port of Rotterdam we generated anomalies related to a vessel's velocity using a Markov model. The markov model, depicted below, has three states: normal, fast and slow. In the slow and fast states the vessel's velocity is respectively divided or multiplied by a scalar. The arrows in the figure below represent the transition probabilities between states and a transition is performed every two hours (in simulation time). Tugboat malfunction There exists a probability t_i and t_b which denote the chances of the tugboat malfunctioning in an idle state and in a busy state respectively. If a tugboat malfunctions, then the tugboat stops in its current location and is unavailable for 5 hours. After the designated time, it is assumed that the vessel gets fixed and it proceeds to go to its waiting location for a new assignment. If the tugboat malfunctions in an idle state (without an assignment), then it does not have a big impact for vessels other than the usual unavailability consequences. If the tugboat malfunctions and was on its way to a tugboat rendezvous, then a different tugboat is assigned to that vessel. If a tugboat malfunctions when it is tugging a vessel, then the vessel (and all other tugging tugboats) stop and wait for a replacement tugboat to arrive. If a replacement tug is not available, then this check is performed again in 30 simualation minutes (so as to reduce computational overhead a bit). The vessel (and tugboats) waits until the required amount of tugboats is present.","title":"Features"},{"location":"features/#architecture","text":"","title":"Architecture"},{"location":"features/#entity-component-systems","text":"The simulation framework is based on the ESC Esper . This ECS system consists of the following elements: Entities : labels that represent simulated entities (vessels, berths, etc.). They have no properties or methods. Components provide properties and processors provide method implementations Components : data objects (such as position, velocity, etc.). They should NOT include any method or computation Processors : classes that process a set of entities identified by their components. For example a vessel entity might be characterized by a position, velocity and vessel_info components As an example consider the mock simulation world in the figure below. There are two classes of entities, namely Vessel and Terminal which are respectively composed by ( Position , Path ) and ( Position ). Each system processes a subset of entities at each tick of the simulation, for example, the Rendering system will query all entities who have a Position component and display them on-screen, while the Movement system will only care about entities with Position and Path components.","title":"Entity-component systems"},{"location":"features/#packages","text":"This section provides a schematic overview of the major packages that compose the simulation framework","title":"Packages"},{"location":"features/#components","text":"","title":"Components"},{"location":"features/#environment","text":"","title":"Environment"},{"location":"features/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"features/#processors","text":"","title":"Processors"},{"location":"features/#simulated-agents-and-infrastructure","text":"The simulation can simulate the following agents and infrastructure components:","title":"Simulated agents and infrastructure"},{"location":"features/#agents","text":"","title":"Agents"},{"location":"features/#vessel","text":"The ship which needs the port services for loading/unloading cargo, maintenance, fuel, etc. The behavior of incoming vessels is simulated using the following state machine: Following the previous diagrams vessels are either routed to an anchorage, a rendezvous or straight to the terminal depending on resources requests and availability (a more detailed diagram is shown in the messaging section). The navigation of vessels is simulated using paths extracted (and augmented) from AIS data. Movement is simulated using a simple speed based model (where acceleration/deceleration is instantaneous).","title":"Vessel"},{"location":"features/#pilots","text":"Pilots (working for the port) assist vessels entering or leaving a port. Pilots do so as they are experts of the port infrastructure and navigating big vessels in the port. The pilots are described by the following FSM diagram:","title":"Pilots"},{"location":"features/#tugboats","text":"A tugboat is a strongly built powerful boat, that is used for towing and pushing ( Merriam-Webster ). Tugboats are used to maneuver large vessels inside the port with more accuracy and precision. The simulated behavior of tugboats is described by the following FSM diagram:","title":"Tugboats"},{"location":"features/#infrastructure","text":"","title":"Infrastructure"},{"location":"features/#berth","text":"The location where a ship lies when being serviced or waiting for departure. Berths are grouped into a terminal, which is usually dedicated to a single cargo type (e.g. oil, containers, etc.)","title":"Berth"},{"location":"features/#anchorage","text":"An anchorage is defined as the area where vessels drop anchor, or anchor, awaiting their entry into that part of the harbour reserved for performing typical port type operations (loading, unloading, supplies, repairs, etc.), which however does not exclude these operations frequently being undertaken at the anchorages (Puertos Del Estado, 2007)","title":"Anchorage"},{"location":"features/#tugboats-locations","text":"Rendezvous locations: meeting points between vessels and tugboats where tugboats are connected to vessels and the tugging process starts Waiting locations: locations used to park tugboats when their services are not required","title":"Tugboats locations"},{"location":"features/#pilot-locations","text":"Rendezvous locations: meeting points between vessels and pilots where pilots board the vessel and pilotage starts Waiting locations: locations used to park pilot tender vessels when their services are not required","title":"Pilot locations"},{"location":"features/#port-sections","text":"The frameworks allows to separate the port waterways (navigable area inside the port) in sections. Each section has the following constraints: Maximum and minimum speed","title":"Port sections"},{"location":"features/#agents-communication","text":"The agents in the simulation can communicate via the MessageBroker . Each message has a sender , a receiver a message_type and an optional data property. Simulation entities are identified by their entity id and unique agents (such as the harbour master) are identified by a string. In practice, this means that if a vessel (say entity 195) wants to send a message to the harbour master the sender will be ent:195 and the receiver will be harbour-master . Such a message can be created as follows message = SimulationMessage( sender=\"vessel:195\", destination=\"harbour-master\", message=VesselMessageType.CHANGE_SECTION) In the current implementation only vessel agents communicate with the harbour-master agent which takes care of allocating port resources to the vessel. In practice this does not happen, for instance tugboat companies communicate directly with the shipping company that owns the vessel for booking tugs.","title":"Agents communication"},{"location":"features/#vessel-messages","text":"Each vessel entity generates the various messages and sends them to the harbour-master . The following diagram describes which messages are sent to the harbour-master entity at each state of the vessel process (including the decisions taken by the harbour-master entity) The harbour-master processor handles such messages based on a pluggable strategy. The default strategy is in the class DefaultVesselStrategy Moreover, each vessel notifies the harbour-master when it enters/exits a section. These events are not handled directly by the harbour master and a modeller can handle them by setting on_enter_section and on_exit_section on the HarbourMasterProcessor class. For example: hm_processor = HarbourMasterProcessor( world=world, vessel_strategy=vessel_strategy, logger=vessel_event_logger) # Handle the vessel exited section event hm_processor.on_exit_section = lambda msg, ent, vessel_info: ...","title":"Vessel messages"},{"location":"features/#simulated-anomalies","text":"","title":"Simulated anomalies"},{"location":"features/#random-berth-inspection","text":"There exists a probability p that every time a vessel is serviced at a berth, it might happen that a berth inspection occurs. In which case, the berth service time is increased by a random time (or, by default, 5 hours).","title":"Random berth inspection"},{"location":"features/#unusual-vessel-velocities","text":"Using the simulation of the Port of Rotterdam we generated anomalies related to a vessel's velocity using a Markov model. The markov model, depicted below, has three states: normal, fast and slow. In the slow and fast states the vessel's velocity is respectively divided or multiplied by a scalar. The arrows in the figure below represent the transition probabilities between states and a transition is performed every two hours (in simulation time).","title":"Unusual vessel velocities"},{"location":"features/#tugboat-malfunction","text":"There exists a probability t_i and t_b which denote the chances of the tugboat malfunctioning in an idle state and in a busy state respectively. If a tugboat malfunctions, then the tugboat stops in its current location and is unavailable for 5 hours. After the designated time, it is assumed that the vessel gets fixed and it proceeds to go to its waiting location for a new assignment. If the tugboat malfunctions in an idle state (without an assignment), then it does not have a big impact for vessels other than the usual unavailability consequences. If the tugboat malfunctions and was on its way to a tugboat rendezvous, then a different tugboat is assigned to that vessel. If a tugboat malfunctions when it is tugging a vessel, then the vessel (and all other tugging tugboats) stop and wait for a replacement tugboat to arrive. If a replacement tug is not available, then this check is performed again in 30 simualation minutes (so as to reduce computational overhead a bit). The vessel (and tugboats) waits until the required amount of tugboats is present.","title":"Tugboat malfunction"},{"location":"guide/","text":"Port Simulator This framework is designed to simulate maritime port environments. The system can be de-composed in the following elements: Vessel generation: generates new incoming vessels Anchorages Navigation: simulates vessel navigation based on AIS data Services: tugboats and pilots Terminal: simulate berth operations Vessel: vessel strategy, or, in other words, what should the vessel do? Messaging: communication system between entities The image below highlights which simulation components are implemented (green), partially implemented (yellow) and not yet implemented (red). To quickly run the example model execute the following: python main.py \\ --out sim-output \\ --step 10 \\ --verbose y \\ --graphics y \\ --cache y \\ --seed 567 Vessel generation The vessel generation is handled by the VesselGeneratorProcessor class, this class requires the following parameters: inter_arrival_time_sampler : a function f(vessel_type) that returns the sampled inter-arrival time for the next vessel arrival (of the input type) vessel_info_sampler : a function f(vessel_type) that returns the vessel properties (a VesselInfo object, or a subclass) for the given vessel type spawn_area_filename : path to a geojson file that defines a single polygon, the area in which vessels are generated. See map_data/ocean/spawn.geojson for an example For an example see example_model/berth_service_distribution_factory.py Anchorages Anchorages are implemented as a simple FIFO queuing system. Anchorages are loaded from a GeoJSON file with a single FeatureCollection containing a list of Polygons , each defined as: { \"type\": \"Feature\", \"properties\": { \"name\": \"1\", // Anchorage name \"max_draught\": 10.0, // Max draught in meters \"use\": \"\", // Optional \"id\": 0 // Unique anchorage identifier }, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [1.377333, 42.047833], [1.305833, 42.065863], [1.314286, 42.103538], [1.356744, 42.134278], [1.367560, 42.136667] ] } } See map_data/anchorages/anchorages.geojson for a complete example. The anchorage loading is done via the AnchoragesInitializer class in the following way: anchorages_generator = AnchoragesInitializer(world, anchorages_filename) anchorages_generator.create_anchorages() The anchorage allocation is explained in the Vessel section. Navigation Vessel navigation is simulated using traces extracted from the AIS data. Traces can be created using the tracer tool, stored in the ais-tracer repository. Navigation is handled by the PathFinder singleton, which can be initialized in the following way: path_finder = PathFinder.get_instance() # traces_folder specifies the path to a folder containing a set of traces in GeoJSON files. path_finder.load_traces(traces_folder) The PathFinder takes care of finding suitable routes for incoming and departing vessels. Consult the class for further documentation on its workings. To generate a path from the ocean to a given berth (identified by berth_id ) use the method ocean_berth_path() . To generate a path from a given berth to the ocean use ocean_berth_path() and reverse it using reverse_path() Services Work in progress Terminals and berths Berths are loaded in the model via the BerthInitializer : # BerthServiceDistributionFactory reads a service times csv file # and returns the average service time for each berth berth_service_distribution_factory = BerthServiceDistributionFactory( terminal_service_times_filename) berths_generator = BerthsInitializer( world, berths_filename, berth_service_distribution_factory) berths_generator.create_berths() The berths_filename points to a .csv file with the following fields: id : unique berth identifier name : berth name lat : latitude in WSG84 format lon : longitude in WSG84 format description : optional description type : berth type (not used in the model) max_quay_length : max quay length in meters max_depth : max depth in meters vessel_types : allowed vessel classes terminal : terminal to which the berth belongs to. Terminal names must match the ones in the terminal service times file The berth identifiers should match the ones used in the traces, so, if a trace $x$ connects the ocean to berth 137 there must exist a berth with id 137 in the berths file. Terminal service times are loaded from a .csv file (in the example above terminal_service_times_filename ) with the following columns: terminal : name of the terminal section : section id of the terminal class 1 : average service time in seconds for class 1 vessels class 2 : average service time in seconds for class 1 vessels ... : average service time in seconds for other classes Vessel The behavior of vessel is defined by a strategy class, for an example see the DefaultVesselStrategy class. This class is used by the harbour master to decide what should be the next step for the vessel. # See the class for further documentations vessel_strategy = DefaultVesselStrategy( world=world, anchorage_designator=assign_anchorage, berth_designator=berth_allocation_designator, path_finder=path_finder) The decision system of a vessel is composed of three main elements, the VesselGoalFormulator , which zkeeps track of the current goal and generates an event (by sending a message to the Harbour Master) when the current goal is met. The Harbour Master has a vessel_strategy object which processes the incoming message and returns a decision, which is then in turn sent back to the vessel. This structure allows the vessel strategy to be replaced easily by an alternative strategy. Messaging For more information on messaging see messaging.md","title":"Port Simulator"},{"location":"guide/#port-simulator","text":"This framework is designed to simulate maritime port environments. The system can be de-composed in the following elements: Vessel generation: generates new incoming vessels Anchorages Navigation: simulates vessel navigation based on AIS data Services: tugboats and pilots Terminal: simulate berth operations Vessel: vessel strategy, or, in other words, what should the vessel do? Messaging: communication system between entities The image below highlights which simulation components are implemented (green), partially implemented (yellow) and not yet implemented (red). To quickly run the example model execute the following: python main.py \\ --out sim-output \\ --step 10 \\ --verbose y \\ --graphics y \\ --cache y \\ --seed 567","title":"Port Simulator"},{"location":"guide/#vessel-generation","text":"The vessel generation is handled by the VesselGeneratorProcessor class, this class requires the following parameters: inter_arrival_time_sampler : a function f(vessel_type) that returns the sampled inter-arrival time for the next vessel arrival (of the input type) vessel_info_sampler : a function f(vessel_type) that returns the vessel properties (a VesselInfo object, or a subclass) for the given vessel type spawn_area_filename : path to a geojson file that defines a single polygon, the area in which vessels are generated. See map_data/ocean/spawn.geojson for an example For an example see example_model/berth_service_distribution_factory.py","title":"Vessel generation"},{"location":"guide/#anchorages","text":"Anchorages are implemented as a simple FIFO queuing system. Anchorages are loaded from a GeoJSON file with a single FeatureCollection containing a list of Polygons , each defined as: { \"type\": \"Feature\", \"properties\": { \"name\": \"1\", // Anchorage name \"max_draught\": 10.0, // Max draught in meters \"use\": \"\", // Optional \"id\": 0 // Unique anchorage identifier }, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [ [1.377333, 42.047833], [1.305833, 42.065863], [1.314286, 42.103538], [1.356744, 42.134278], [1.367560, 42.136667] ] } } See map_data/anchorages/anchorages.geojson for a complete example. The anchorage loading is done via the AnchoragesInitializer class in the following way: anchorages_generator = AnchoragesInitializer(world, anchorages_filename) anchorages_generator.create_anchorages() The anchorage allocation is explained in the Vessel section.","title":"Anchorages"},{"location":"guide/#navigation","text":"Vessel navigation is simulated using traces extracted from the AIS data. Traces can be created using the tracer tool, stored in the ais-tracer repository. Navigation is handled by the PathFinder singleton, which can be initialized in the following way: path_finder = PathFinder.get_instance() # traces_folder specifies the path to a folder containing a set of traces in GeoJSON files. path_finder.load_traces(traces_folder) The PathFinder takes care of finding suitable routes for incoming and departing vessels. Consult the class for further documentation on its workings. To generate a path from the ocean to a given berth (identified by berth_id ) use the method ocean_berth_path() . To generate a path from a given berth to the ocean use ocean_berth_path() and reverse it using reverse_path()","title":"Navigation"},{"location":"guide/#services","text":"Work in progress","title":"Services"},{"location":"guide/#terminals-and-berths","text":"Berths are loaded in the model via the BerthInitializer : # BerthServiceDistributionFactory reads a service times csv file # and returns the average service time for each berth berth_service_distribution_factory = BerthServiceDistributionFactory( terminal_service_times_filename) berths_generator = BerthsInitializer( world, berths_filename, berth_service_distribution_factory) berths_generator.create_berths() The berths_filename points to a .csv file with the following fields: id : unique berth identifier name : berth name lat : latitude in WSG84 format lon : longitude in WSG84 format description : optional description type : berth type (not used in the model) max_quay_length : max quay length in meters max_depth : max depth in meters vessel_types : allowed vessel classes terminal : terminal to which the berth belongs to. Terminal names must match the ones in the terminal service times file The berth identifiers should match the ones used in the traces, so, if a trace $x$ connects the ocean to berth 137 there must exist a berth with id 137 in the berths file. Terminal service times are loaded from a .csv file (in the example above terminal_service_times_filename ) with the following columns: terminal : name of the terminal section : section id of the terminal class 1 : average service time in seconds for class 1 vessels class 2 : average service time in seconds for class 1 vessels ... : average service time in seconds for other classes","title":"Terminals and berths"},{"location":"guide/#vessel","text":"The behavior of vessel is defined by a strategy class, for an example see the DefaultVesselStrategy class. This class is used by the harbour master to decide what should be the next step for the vessel. # See the class for further documentations vessel_strategy = DefaultVesselStrategy( world=world, anchorage_designator=assign_anchorage, berth_designator=berth_allocation_designator, path_finder=path_finder) The decision system of a vessel is composed of three main elements, the VesselGoalFormulator , which zkeeps track of the current goal and generates an event (by sending a message to the Harbour Master) when the current goal is met. The Harbour Master has a vessel_strategy object which processes the incoming message and returns a decision, which is then in turn sent back to the vessel. This structure allows the vessel strategy to be replaced easily by an alternative strategy.","title":"Vessel"},{"location":"guide/#messaging","text":"For more information on messaging see messaging.md","title":"Messaging"},{"location":"usage/","text":"Usage Example simulation We have provided an example simulation to illustrate the results and introduce the construction of a custom maritime port simulation. The example simulation was built for the Port of Antwerp and based on mock data made manually using geojson.io , thus, of course, no real-life decisions can be discerned from this. The example model has the following characteristics: Two vessel classes Three cargo types (dry bulk, chemicals, containers) Three berths. Each berth has two distinct ocean -> berth traces Two anchorage areas When a vessel is generated, the simulation checks if some berth that can serve it is available. Specifically, it asks if the content can be processed there, if the size class can be handled, is the quay long enough and if the berth is deep enough for the vessel. If the answer to any of these is no, then the vessel is sent to an anchorage to wait until a berth is available. If the answer to all of these is yes, the vessel proceeds to go to the assigned berth and is serviced there for a time sampled from service time distribution. Afterwards it goes back to the spawn point and leaves the simulation.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#example-simulation","text":"We have provided an example simulation to illustrate the results and introduce the construction of a custom maritime port simulation. The example simulation was built for the Port of Antwerp and based on mock data made manually using geojson.io , thus, of course, no real-life decisions can be discerned from this. The example model has the following characteristics: Two vessel classes Three cargo types (dry bulk, chemicals, containers) Three berths. Each berth has two distinct ocean -> berth traces Two anchorage areas When a vessel is generated, the simulation checks if some berth that can serve it is available. Specifically, it asks if the content can be processed there, if the size class can be handled, is the quay long enough and if the berth is deep enough for the vessel. If the answer to any of these is no, then the vessel is sent to an anchorage to wait until a berth is available. If the answer to all of these is yes, the vessel proceeds to go to the assigned berth and is serviced there for a time sampled from service time distribution. Afterwards it goes back to the spawn point and leaves the simulation.","title":"Example simulation"}]}